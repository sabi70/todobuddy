{"ast":null,"code":"/**\n* @vue/compiler-ssr v3.5.6\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar compilerDom = require('@vue/compiler-dom');\nvar shared = require('@vue/shared');\nconst SSR_INTERPOLATE = Symbol(`ssrInterpolate`);\nconst SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);\nconst SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);\nconst SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);\nconst SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`);\nconst SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);\nconst SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);\nconst SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);\nconst SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);\nconst SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);\nconst SSR_RENDER_LIST = Symbol(`ssrRenderList`);\nconst SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);\nconst SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);\nconst SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);\nconst SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);\nconst SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);\nconst SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);\nconst SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);\nconst SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);\nconst ssrHelpers = {\n  [SSR_INTERPOLATE]: `ssrInterpolate`,\n  [SSR_RENDER_VNODE]: `ssrRenderVNode`,\n  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\n  [SSR_RENDER_SLOT]: `ssrRenderSlot`,\n  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,\n  [SSR_RENDER_CLASS]: `ssrRenderClass`,\n  [SSR_RENDER_STYLE]: `ssrRenderStyle`,\n  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\n  [SSR_RENDER_ATTR]: `ssrRenderAttr`,\n  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\n  [SSR_RENDER_LIST]: `ssrRenderList`,\n  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\n  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\n  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\n  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\n  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\n  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\n  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\n  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`\n};\ncompilerDom.registerRuntimeHelpers(ssrHelpers);\nconst ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);\nfunction ssrProcessIf(node, context, disableNestedFragments = false, disableCommentAsIfAlternate = false) {\n  const [rootBranch] = node.branches;\n  const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));\n  context.pushStatement(ifStatement);\n  let currentIf = ifStatement;\n  for (let i = 1; i < node.branches.length; i++) {\n    const branch = node.branches[i];\n    const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);\n    if (branch.condition) {\n      currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);\n    } else {\n      currentIf.alternate = branchBlockStatement;\n    }\n  }\n  if (!currentIf.alternate && !disableCommentAsIfAlternate) {\n    currentIf.alternate = compilerDom.createBlockStatement([compilerDom.createCallExpression(`_push`, [\"`<!---->`\"])]);\n  }\n}\nfunction processIfBranch(branch, context, disableNestedFragments = false) {\n  const {\n    children\n  } = branch;\n  const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) &&\n  // optimize away nested fragments when the only child is a ForNode\n  !(children.length === 1 && children[0].type === 11);\n  return processChildrenAsStatement(branch, context, needFragmentWrapper);\n}\nconst ssrTransformFor = compilerDom.createStructuralDirectiveTransform(\"for\", compilerDom.processFor);\nfunction ssrProcessFor(node, context, disableNestedFragments = false) {\n  const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);\n  const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node.parseResult));\n  renderLoop.body = processChildrenAsStatement(node, context, needFragmentWrapper);\n  if (!disableNestedFragments) {\n    context.pushStringPart(`<!--[-->`);\n  }\n  context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [node.source, renderLoop]));\n  if (!disableNestedFragments) {\n    context.pushStringPart(`<!--]-->`);\n  }\n}\nconst ssrTransformSlotOutlet = (node, context) => {\n  if (compilerDom.isSlotOutlet(node)) {\n    const {\n      slotName,\n      slotProps\n    } = compilerDom.processSlotOutlet(node, context);\n    const args = [`_ctx.$slots`, slotName, slotProps || `{}`,\n    // fallback content placeholder. will be replaced in the process phase\n    `null`, `_push`, `_parent`];\n    if (context.scopeId && context.slotted !== false) {\n      args.push(`\"${context.scopeId}-s\"`);\n    }\n    let method = SSR_RENDER_SLOT;\n    let parent = context.parent;\n    if (parent) {\n      const children = parent.children;\n      if (parent.type === 10) {\n        parent = context.grandParent;\n      }\n      let componentType;\n      if (parent.type === 1 && parent.tagType === 1 && ((componentType = compilerDom.resolveComponentType(parent, context, true)) === compilerDom.TRANSITION || componentType === compilerDom.TRANSITION_GROUP) && children.filter(c => c.type === 1).length === 1) {\n        method = SSR_RENDER_SLOT_INNER;\n        if (!(context.scopeId && context.slotted !== false)) {\n          args.push(\"null\");\n        }\n        args.push(\"true\");\n      }\n    }\n    node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(method), args);\n  }\n};\nfunction ssrProcessSlotOutlet(node, context) {\n  const renderCall = node.ssrCodegenNode;\n  if (node.children.length) {\n    const fallbackRenderFn = compilerDom.createFunctionExpression([]);\n    fallbackRenderFn.body = processChildrenAsStatement(node, context);\n    renderCall.arguments[3] = fallbackRenderFn;\n  }\n  if (context.withSlotScopeId) {\n    const slotScopeId = renderCall.arguments[6];\n    renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;\n  }\n  context.pushStatement(node.ssrCodegenNode);\n}\nfunction createSSRCompilerError(code, loc) {\n  return compilerDom.createCompilerError(code, loc, SSRErrorMessages);\n}\nconst SSRErrorMessages = {\n  [65]: `Unsafe attribute name for SSR.`,\n  [66]: `Missing the 'to' prop on teleport element.`,\n  [67]: `Invalid AST node during SSR transform.`\n};\nfunction ssrProcessTeleport(node, context) {\n  const targetProp = compilerDom.findProp(node, \"to\");\n  if (!targetProp) {\n    context.onError(createSSRCompilerError(66, node.loc));\n    return;\n  }\n  let target;\n  if (targetProp.type === 6) {\n    target = targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);\n  } else {\n    target = targetProp.exp;\n  }\n  if (!target) {\n    context.onError(createSSRCompilerError(66, targetProp.loc));\n    return;\n  }\n  const disabledProp = compilerDom.findProp(node, \"disabled\", false, true\n  /* allow empty */);\n  const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;\n  const contentRenderFn = compilerDom.createFunctionExpression([`_push`], void 0,\n  // Body is added later\n  true,\n  // newline\n  false,\n  // isSlot\n  node.loc);\n  contentRenderFn.body = processChildrenAsStatement(node, context);\n  context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [`_push`, contentRenderFn, target, disabled, `_parent`]));\n}\nconst wipMap$3 = /* @__PURE__ */new WeakMap();\nfunction ssrTransformSuspense(node, context) {\n  return () => {\n    if (node.children.length) {\n      const wipEntry = {\n        slotsExp: null,\n        // to be immediately set\n        wipSlots: []\n      };\n      wipMap$3.set(node, wipEntry);\n      wipEntry.slotsExp = compilerDom.buildSlots(node, context, (_props, _vForExp, children, loc) => {\n        const fn = compilerDom.createFunctionExpression([], void 0,\n        // no return, assign body later\n        true,\n        // newline\n        false,\n        // suspense slots are not treated as normal slots\n        loc);\n        wipEntry.wipSlots.push({\n          fn,\n          children\n        });\n        return fn;\n      }).slots;\n    }\n  };\n}\nfunction ssrProcessSuspense(node, context) {\n  const wipEntry = wipMap$3.get(node);\n  if (!wipEntry) {\n    return;\n  }\n  const {\n    slotsExp,\n    wipSlots\n  } = wipEntry;\n  for (let i = 0; i < wipSlots.length; i++) {\n    const slot = wipSlots[i];\n    slot.fn.body = processChildrenAsStatement(slot, context);\n  }\n  context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [`_push`, slotsExp]));\n}\nconst rawChildrenMap = /* @__PURE__ */new WeakMap();\nconst ssrTransformElement = (node, context) => {\n  if (node.type !== 1 || node.tagType !== 0) {\n    return;\n  }\n  return function ssrPostTransformElement() {\n    const openTag = [`<${node.tag}`];\n    const needTagForRuntime = node.tag === \"textarea\" || node.tag.indexOf(\"-\") > 0;\n    const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);\n    const hasCustomDir = node.props.some(p => p.type === 7 && !shared.isBuiltInDirective(p.name));\n    const needMergeProps = hasDynamicVBind || hasCustomDir;\n    if (needMergeProps) {\n      const {\n        props,\n        directives\n      } = compilerDom.buildProps(node, context, node.props, false, false, true);\n      if (props || directives.length) {\n        const mergedProps = buildSSRProps(props, directives, context);\n        const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [mergedProps]);\n        if (node.tag === \"textarea\") {\n          const existingText = node.children[0];\n          if (!existingText || existingText.type !== 5) {\n            const tempId = `_temp${context.temps++}`;\n            propsExp.arguments = [compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), mergedProps)];\n            rawChildrenMap.set(node, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`\"value\" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)]));\n          }\n        } else if (node.tag === \"input\") {\n          const vModel = findVModel(node);\n          if (vModel) {\n            const tempId = `_temp${context.temps++}`;\n            const tempExp = compilerDom.createSimpleExpression(tempId, false);\n            propsExp.arguments = [compilerDom.createSequenceExpression([compilerDom.createAssignmentExpression(tempExp, mergedProps), compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [tempExp, compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [tempExp,\n            // existing props\n            vModel.exp\n            // model\n            ])])])];\n          }\n        } else if (directives.length && !node.children.length) {\n          const tempId = `_temp${context.temps++}`;\n          propsExp.arguments = [compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), mergedProps)];\n          rawChildrenMap.set(node, compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`\"textContent\" in ${tempId}`, false), compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [compilerDom.createSimpleExpression(`${tempId}.textContent`, false)]), compilerDom.createSimpleExpression(`${tempId}.innerHTML ?? ''`, false), false));\n        }\n        if (needTagForRuntime) {\n          propsExp.arguments.push(`\"${node.tag}\"`);\n        }\n        openTag.push(propsExp);\n      }\n    }\n    let dynamicClassBinding = void 0;\n    let staticClassBinding = void 0;\n    let dynamicStyleBinding = void 0;\n    for (let i = 0; i < node.props.length; i++) {\n      const prop = node.props[i];\n      if (node.tag === \"input\" && isTrueFalseValue(prop)) {\n        continue;\n      }\n      if (prop.type === 7) {\n        if (prop.name === \"html\" && prop.exp) {\n          rawChildrenMap.set(node, compilerDom.createCompoundExpression([`(`, prop.exp, `) ?? ''`]));\n        } else if (prop.name === \"text\" && prop.exp) {\n          node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\n        } else if (prop.name === \"slot\") {\n          context.onError(compilerDom.createCompilerError(40, prop.loc));\n        } else if (isTextareaWithValue(node, prop) && prop.exp) {\n          if (!needMergeProps) {\n            node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\n          }\n        } else if (!needMergeProps && prop.name !== \"on\") {\n          const directiveTransform = context.directiveTransforms[prop.name];\n          if (directiveTransform) {\n            const {\n              props,\n              ssrTagParts\n            } = directiveTransform(prop, node, context);\n            if (ssrTagParts) {\n              openTag.push(...ssrTagParts);\n            }\n            for (let j = 0; j < props.length; j++) {\n              const {\n                key,\n                value\n              } = props[j];\n              if (compilerDom.isStaticExp(key)) {\n                let attrName = key.content;\n                if (attrName === \"key\" || attrName === \"ref\") {\n                  continue;\n                }\n                if (attrName === \"class\") {\n                  openTag.push(` class=\"`, dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value]), `\"`);\n                } else if (attrName === \"style\") {\n                  if (dynamicStyleBinding) {\n                    mergeCall(dynamicStyleBinding, value);\n                  } else {\n                    openTag.push(` style=\"`, dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value]), `\"`);\n                  }\n                } else {\n                  attrName = node.tag.indexOf(\"-\") > 0 ? attrName : shared.propsToAttrMap[attrName] || attrName.toLowerCase();\n                  if (shared.isBooleanAttr(attrName)) {\n                    openTag.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), compilerDom.createSimpleExpression(\" \" + attrName, true), compilerDom.createSimpleExpression(\"\", true), false));\n                  } else if (shared.isSSRSafeAttrName(attrName)) {\n                    openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [key, value]));\n                  } else {\n                    context.onError(createSSRCompilerError(65, key.loc));\n                  }\n                }\n              } else {\n                const args = [key, value];\n                if (needTagForRuntime) {\n                  args.push(`\"${node.tag}\"`);\n                }\n                openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));\n              }\n            }\n          }\n        }\n      } else {\n        const name = prop.name;\n        if (node.tag === \"textarea\" && name === \"value\" && prop.value) {\n          rawChildrenMap.set(node, shared.escapeHtml(prop.value.content));\n        } else if (!needMergeProps) {\n          if (name === \"key\" || name === \"ref\") {\n            continue;\n          }\n          if (name === \"class\" && prop.value) {\n            staticClassBinding = JSON.stringify(prop.value.content);\n          }\n          openTag.push(` ${prop.name}` + (prop.value ? `=\"${shared.escapeHtml(prop.value.content)}\"` : ``));\n        }\n      }\n    }\n    if (dynamicClassBinding && staticClassBinding) {\n      mergeCall(dynamicClassBinding, staticClassBinding);\n      removeStaticBinding(openTag, \"class\");\n    }\n    if (context.scopeId) {\n      openTag.push(` ${context.scopeId}`);\n    }\n    node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);\n  };\n};\nfunction buildSSRProps(props, directives, context) {\n  let mergePropsArgs = [];\n  if (props) {\n    if (props.type === 14) {\n      mergePropsArgs = props.arguments;\n    } else {\n      mergePropsArgs.push(props);\n    }\n  }\n  if (directives.length) {\n    for (const dir of directives) {\n      mergePropsArgs.push(compilerDom.createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [`_ctx`, ...compilerDom.buildDirectiveArgs(dir, context).elements]));\n    }\n  }\n  return mergePropsArgs.length > 1 ? compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), mergePropsArgs) : mergePropsArgs[0];\n}\nfunction isTrueFalseValue(prop) {\n  if (prop.type === 7) {\n    return prop.name === \"bind\" && prop.arg && compilerDom.isStaticExp(prop.arg) && (prop.arg.content === \"true-value\" || prop.arg.content === \"false-value\");\n  } else {\n    return prop.name === \"true-value\" || prop.name === \"false-value\";\n  }\n}\nfunction isTextareaWithValue(node, prop) {\n  return !!(node.tag === \"textarea\" && prop.name === \"bind\" && compilerDom.isStaticArgOf(prop.arg, \"value\"));\n}\nfunction mergeCall(call, arg) {\n  const existing = call.arguments[0];\n  if (existing.type === 17) {\n    existing.elements.push(arg);\n  } else {\n    call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);\n  }\n}\nfunction removeStaticBinding(tag, binding) {\n  const regExp = new RegExp(`^ ${binding}=\".+\"$`);\n  const i = tag.findIndex(e => typeof e === \"string\" && regExp.test(e));\n  if (i > -1) {\n    tag.splice(i, 1);\n  }\n}\nfunction findVModel(node) {\n  return node.props.find(p => p.type === 7 && p.name === \"model\" && p.exp);\n}\nfunction ssrProcessElement(node, context) {\n  const isVoidTag = context.options.isVoidTag || shared.NO;\n  const elementsToAdd = node.ssrCodegenNode.elements;\n  for (let j = 0; j < elementsToAdd.length; j++) {\n    context.pushStringPart(elementsToAdd[j]);\n  }\n  if (context.withSlotScopeId) {\n    context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));\n  }\n  context.pushStringPart(`>`);\n  const rawChildren = rawChildrenMap.get(node);\n  if (rawChildren) {\n    context.pushStringPart(rawChildren);\n  } else if (node.children.length) {\n    processChildren(node, context);\n  }\n  if (!isVoidTag(node.tag)) {\n    context.pushStringPart(`</${node.tag}>`);\n  }\n}\nconst wipMap$2 = /* @__PURE__ */new WeakMap();\nfunction ssrTransformTransitionGroup(node, context) {\n  return () => {\n    const tag = compilerDom.findProp(node, \"tag\");\n    if (tag) {\n      const otherProps = node.props.filter(p => p !== tag);\n      const {\n        props,\n        directives\n      } = compilerDom.buildProps(node, context, otherProps, true, false, true);\n      let propsExp = null;\n      if (props || directives.length) {\n        propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [buildSSRProps(props, directives, context)]);\n      }\n      wipMap$2.set(node, {\n        tag,\n        propsExp,\n        scopeId: context.scopeId || null\n      });\n    }\n  };\n}\nfunction ssrProcessTransitionGroup(node, context) {\n  const entry = wipMap$2.get(node);\n  if (entry) {\n    const {\n      tag,\n      propsExp,\n      scopeId\n    } = entry;\n    if (tag.type === 7) {\n      context.pushStringPart(`<`);\n      context.pushStringPart(tag.exp);\n      if (propsExp) {\n        context.pushStringPart(propsExp);\n      }\n      if (scopeId) {\n        context.pushStringPart(` ${scopeId}`);\n      }\n      context.pushStringPart(`>`);\n      processChildren(node, context, false,\n      /**\n       * TransitionGroup has the special runtime behavior of flattening and\n       * concatenating all children into a single fragment (in order for them to\n       * be patched using the same key map) so we need to account for that here\n       * by disabling nested fragment wrappers from being generated.\n       */\n      true,\n      /**\n       * TransitionGroup filters out comment children at runtime and thus\n       * doesn't expect comments to be present during hydration. We need to\n       * account for that by disabling the empty comment that is otherwise\n       * rendered for a falsy v-if that has no v-else specified. (#6715)\n       */\n      true);\n      context.pushStringPart(`</`);\n      context.pushStringPart(tag.exp);\n      context.pushStringPart(`>`);\n    } else {\n      context.pushStringPart(`<${tag.value.content}`);\n      if (propsExp) {\n        context.pushStringPart(propsExp);\n      }\n      if (scopeId) {\n        context.pushStringPart(` ${scopeId}`);\n      }\n      context.pushStringPart(`>`);\n      processChildren(node, context, false, true, true);\n      context.pushStringPart(`</${tag.value.content}>`);\n    }\n  } else {\n    processChildren(node, context, true, true, true);\n  }\n}\nconst wipMap$1 = /* @__PURE__ */new WeakMap();\nfunction ssrTransformTransition(node, context) {\n  return () => {\n    const appear = compilerDom.findProp(node, \"appear\", false, true);\n    wipMap$1.set(node, !!appear);\n  };\n}\nfunction ssrProcessTransition(node, context) {\n  node.children = node.children.filter(c => c.type !== 3);\n  const appear = wipMap$1.get(node);\n  if (appear) {\n    context.pushStringPart(`<template>`);\n    processChildren(node, context, false, true);\n    context.pushStringPart(`</template>`);\n  } else {\n    processChildren(node, context, false, true);\n  }\n}\nconst wipMap = /* @__PURE__ */new WeakMap();\nconst WIP_SLOT = Symbol();\nconst componentTypeMap = /* @__PURE__ */new WeakMap();\nconst ssrTransformComponent = (node, context) => {\n  if (node.type !== 1 || node.tagType !== 1) {\n    return;\n  }\n  const component = compilerDom.resolveComponentType(node, context, true\n  /* ssr */);\n  const isDynamicComponent = shared.isObject(component) && component.callee === compilerDom.RESOLVE_DYNAMIC_COMPONENT;\n  componentTypeMap.set(node, component);\n  if (shared.isSymbol(component)) {\n    if (component === compilerDom.SUSPENSE) {\n      return ssrTransformSuspense(node, context);\n    } else if (component === compilerDom.TRANSITION_GROUP) {\n      return ssrTransformTransitionGroup(node, context);\n    } else if (component === compilerDom.TRANSITION) {\n      return ssrTransformTransition(node);\n    }\n    return;\n  }\n  const vnodeBranches = [];\n  const clonedNode = clone(node);\n  return function ssrPostTransformComponent() {\n    if (clonedNode.children.length) {\n      compilerDom.buildSlots(clonedNode, context, (props, vFor, children) => {\n        vnodeBranches.push(createVNodeSlotBranch(props, vFor, children, context));\n        return compilerDom.createFunctionExpression(void 0);\n      });\n    }\n    let propsExp = `null`;\n    if (node.props.length) {\n      const {\n        props,\n        directives\n      } = compilerDom.buildProps(node, context, void 0, true, isDynamicComponent);\n      if (props || directives.length) {\n        propsExp = buildSSRProps(props, directives, context);\n      }\n    }\n    const wipEntries = [];\n    wipMap.set(node, wipEntries);\n    const buildSSRSlotFn = (props, _vForExp, children, loc) => {\n      const param0 = props && compilerDom.stringifyExpression(props) || `_`;\n      const fn = compilerDom.createFunctionExpression([param0, `_push`, `_parent`, `_scopeId`], void 0,\n      // no return, assign body later\n      true,\n      // newline\n      true,\n      // isSlot\n      loc);\n      wipEntries.push({\n        type: WIP_SLOT,\n        fn,\n        children,\n        // also collect the corresponding vnode branch built earlier\n        vnodeBranch: vnodeBranches[wipEntries.length]\n      });\n      return fn;\n    };\n    const slots = node.children.length ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots : `null`;\n    if (typeof component !== \"string\") {\n      node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [`_push`, compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [component, propsExp, slots]), `_parent`]);\n    } else {\n      node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, propsExp, slots, `_parent`]);\n    }\n  };\n};\nfunction ssrProcessComponent(node, context, parent) {\n  const component = componentTypeMap.get(node);\n  if (!node.ssrCodegenNode) {\n    if (component === compilerDom.TELEPORT) {\n      return ssrProcessTeleport(node, context);\n    } else if (component === compilerDom.SUSPENSE) {\n      return ssrProcessSuspense(node, context);\n    } else if (component === compilerDom.TRANSITION_GROUP) {\n      return ssrProcessTransitionGroup(node, context);\n    } else {\n      if (parent.type === WIP_SLOT) {\n        context.pushStringPart(``);\n      }\n      if (component === compilerDom.TRANSITION) {\n        return ssrProcessTransition(node, context);\n      }\n      processChildren(node, context);\n    }\n  } else {\n    const wipEntries = wipMap.get(node) || [];\n    for (let i = 0; i < wipEntries.length; i++) {\n      const {\n        fn,\n        vnodeBranch\n      } = wipEntries[i];\n      fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(wipEntries[i], context, false, true), vnodeBranch);\n    }\n    if (context.withSlotScopeId) {\n      node.ssrCodegenNode.arguments.push(`_scopeId`);\n    }\n    if (typeof component === \"string\") {\n      context.pushStatement(compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode]));\n    } else {\n      context.pushStatement(node.ssrCodegenNode);\n    }\n  }\n}\nconst rawOptionsMap = /* @__PURE__ */new WeakMap();\nconst [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];\nconst vnodeDirectiveTransforms = {\n  ...baseDirectiveTransforms,\n  ...compilerDom.DOMDirectiveTransforms\n};\nfunction createVNodeSlotBranch(slotProps, vFor, children, parentContext) {\n  const rawOptions = rawOptionsMap.get(parentContext.root);\n  const subOptions = {\n    ...rawOptions,\n    // overwrite with vnode-based transforms\n    nodeTransforms: [...vnodeNodeTransforms, ...(rawOptions.nodeTransforms || [])],\n    directiveTransforms: {\n      ...vnodeDirectiveTransforms,\n      ...(rawOptions.directiveTransforms || {})\n    }\n  };\n  const wrapperProps = [];\n  if (slotProps) {\n    wrapperProps.push({\n      type: 7,\n      name: \"slot\",\n      exp: slotProps,\n      arg: void 0,\n      modifiers: [],\n      loc: compilerDom.locStub\n    });\n  }\n  if (vFor) {\n    wrapperProps.push(shared.extend({}, vFor));\n  }\n  const wrapperNode = {\n    type: 1,\n    ns: 0,\n    tag: \"template\",\n    tagType: 3,\n    props: wrapperProps,\n    children,\n    loc: compilerDom.locStub,\n    codegenNode: void 0\n  };\n  subTransform(wrapperNode, subOptions, parentContext);\n  return compilerDom.createReturnStatement(children);\n}\nfunction subTransform(node, options, parentContext) {\n  const childRoot = compilerDom.createRoot([node]);\n  const childContext = compilerDom.createTransformContext(childRoot, options);\n  childContext.ssr = false;\n  childContext.scopes = {\n    ...parentContext.scopes\n  };\n  childContext.identifiers = {\n    ...parentContext.identifiers\n  };\n  childContext.imports = parentContext.imports;\n  compilerDom.traverseNode(childRoot, childContext);\n  [\"helpers\", \"components\", \"directives\"].forEach(key => {\n    childContext[key].forEach((value, helperKey) => {\n      if (key === \"helpers\") {\n        const parentCount = parentContext.helpers.get(helperKey);\n        if (parentCount === void 0) {\n          parentContext.helpers.set(helperKey, value);\n        } else {\n          parentContext.helpers.set(helperKey, value + parentCount);\n        }\n      } else {\n        parentContext[key].add(value);\n      }\n    });\n  });\n}\nfunction clone(v) {\n  if (shared.isArray(v)) {\n    return v.map(clone);\n  } else if (shared.isPlainObject(v)) {\n    const res = {};\n    for (const key in v) {\n      res[key] = clone(v[key]);\n    }\n    return res;\n  } else {\n    return v;\n  }\n}\nfunction ssrCodegenTransform(ast, options) {\n  const context = createSSRTransformContext(ast, options);\n  if (options.ssrCssVars) {\n    const cssContext = compilerDom.createTransformContext(compilerDom.createRoot([]), options);\n    const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options.ssrCssVars, false), cssContext);\n    context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));\n    Array.from(cssContext.helpers.keys()).forEach(helper => {\n      ast.helpers.add(helper);\n    });\n  }\n  const isFragment = ast.children.length > 1 && ast.children.some(c => !compilerDom.isText(c));\n  processChildren(ast, context, isFragment);\n  ast.codegenNode = compilerDom.createBlockStatement(context.body);\n  ast.ssrHelpers = Array.from(/* @__PURE__ */new Set([...Array.from(ast.helpers).filter(h => h in ssrHelpers), ...context.helpers]));\n  ast.helpers = new Set(Array.from(ast.helpers).filter(h => !(h in ssrHelpers)));\n}\nfunction createSSRTransformContext(root, options, helpers = /* @__PURE__ */new Set(), withSlotScopeId = false) {\n  const body = [];\n  let currentString = null;\n  return {\n    root,\n    options,\n    body,\n    helpers,\n    withSlotScopeId,\n    onError: options.onError || (e => {\n      throw e;\n    }),\n    helper(name) {\n      helpers.add(name);\n      return name;\n    },\n    pushStringPart(part) {\n      if (!currentString) {\n        const currentCall = compilerDom.createCallExpression(`_push`);\n        body.push(currentCall);\n        currentString = compilerDom.createTemplateLiteral([]);\n        currentCall.arguments.push(currentString);\n      }\n      const bufferedElements = currentString.elements;\n      const lastItem = bufferedElements[bufferedElements.length - 1];\n      if (shared.isString(part) && shared.isString(lastItem)) {\n        bufferedElements[bufferedElements.length - 1] += part;\n      } else {\n        bufferedElements.push(part);\n      }\n    },\n    pushStatement(statement) {\n      currentString = null;\n      body.push(statement);\n    }\n  };\n}\nfunction createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {\n  return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);\n}\nfunction processChildren(parent, context, asFragment = false, disableNestedFragments = false, disableCommentAsIfAlternate = false) {\n  if (asFragment) {\n    context.pushStringPart(`<!--[-->`);\n  }\n  const {\n    children\n  } = parent;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    switch (child.type) {\n      case 1:\n        switch (child.tagType) {\n          case 0:\n            ssrProcessElement(child, context);\n            break;\n          case 1:\n            ssrProcessComponent(child, context, parent);\n            break;\n          case 2:\n            ssrProcessSlotOutlet(child, context);\n            break;\n          case 3:\n            break;\n          default:\n            context.onError(createSSRCompilerError(67, child.loc));\n            const exhaustiveCheck2 = child;\n            return exhaustiveCheck2;\n        }\n        break;\n      case 2:\n        context.pushStringPart(shared.escapeHtml(child.content));\n        break;\n      case 3:\n        context.pushStringPart(`<!--${child.content}-->`);\n        break;\n      case 5:\n        context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));\n        break;\n      case 9:\n        ssrProcessIf(child, context, disableNestedFragments, disableCommentAsIfAlternate);\n        break;\n      case 11:\n        ssrProcessFor(child, context, disableNestedFragments);\n        break;\n      case 10:\n        break;\n      case 12:\n      case 8:\n        break;\n      default:\n        context.onError(createSSRCompilerError(67, child.loc));\n        const exhaustiveCheck = child;\n        return exhaustiveCheck;\n    }\n  }\n  if (asFragment) {\n    context.pushStringPart(`<!--]-->`);\n  }\n}\nfunction processChildrenAsStatement(parent, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {\n  const childContext = createChildContext(parentContext, withSlotScopeId);\n  processChildren(parent, childContext, asFragment);\n  return compilerDom.createBlockStatement(childContext.body);\n}\nconst ssrTransformModel = (dir, node, context) => {\n  const model = dir.exp;\n  function checkDuplicatedValue() {\n    const value = compilerDom.findProp(node, \"value\");\n    if (value) {\n      context.onError(compilerDom.createDOMCompilerError(60, value.loc));\n    }\n  }\n  function processOption(plainNode) {\n    if (plainNode.tag === \"option\") {\n      if (plainNode.props.findIndex(p => p.name === \"selected\") === -1) {\n        const value = findValueBinding(plainNode);\n        plainNode.ssrCodegenNode.elements.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [model, value]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [model, value]))]), compilerDom.createSimpleExpression(\" selected\", true), compilerDom.createSimpleExpression(\"\", true), false));\n      }\n    } else if (plainNode.tag === \"optgroup\") {\n      plainNode.children.forEach(option => processOption(option));\n    }\n  }\n  if (node.tagType === 0) {\n    const res = {\n      props: []\n    };\n    const defaultProps = [\n    // default value binding for text type inputs\n    compilerDom.createObjectProperty(`value`, model)];\n    if (node.tag === \"input\") {\n      const type = compilerDom.findProp(node, \"type\");\n      if (type) {\n        const value = findValueBinding(node);\n        if (type.type === 7) {\n          res.ssrTagParts = [compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [type.exp, model, value])];\n        } else if (type.value) {\n          switch (type.value.content) {\n            case \"radio\":\n              res.props = [compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [model, value]))];\n              break;\n            case \"checkbox\":\n              const trueValueBinding = compilerDom.findProp(node, \"true-value\");\n              if (trueValueBinding) {\n                const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;\n                res.props = [compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [model, trueValue]))];\n              } else {\n                res.props = [compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [model, value]), model))];\n              }\n              break;\n            case \"file\":\n              context.onError(compilerDom.createDOMCompilerError(59, dir.loc));\n              break;\n            default:\n              checkDuplicatedValue();\n              res.props = defaultProps;\n              break;\n          }\n        }\n      } else if (compilerDom.hasDynamicKeyVBind(node)) ;else {\n        checkDuplicatedValue();\n        res.props = defaultProps;\n      }\n    } else if (node.tag === \"textarea\") {\n      checkDuplicatedValue();\n      node.children = [compilerDom.createInterpolation(model, model.loc)];\n    } else if (node.tag === \"select\") {\n      node.children.forEach(child => {\n        if (child.type === 1) {\n          processOption(child);\n        }\n      });\n    } else {\n      context.onError(compilerDom.createDOMCompilerError(57, dir.loc));\n    }\n    return res;\n  } else {\n    return compilerDom.transformModel(dir, node, context);\n  }\n};\nfunction findValueBinding(node) {\n  const valueBinding = compilerDom.findProp(node, \"value\");\n  return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : compilerDom.createSimpleExpression(valueBinding.value.content, true) : compilerDom.createSimpleExpression(`null`, false);\n}\nconst ssrTransformShow = (dir, node, context) => {\n  if (!dir.exp) {\n    context.onError(compilerDom.createDOMCompilerError(61));\n  }\n  return {\n    props: [compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(dir.exp, compilerDom.createSimpleExpression(`null`, false), compilerDom.createObjectExpression([compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))]), false))]\n  };\n};\nconst filterChild = node => node.children.filter(n => n.type !== 3);\nconst hasSingleChild = node => filterChild(node).length === 1;\nconst ssrInjectFallthroughAttrs = (node, context) => {\n  if (node.type === 0) {\n    context.identifiers._attrs = 1;\n  }\n  if (node.type === 1 && node.tagType === 1 && (node.tag === \"transition\" || node.tag === \"Transition\" || node.tag === \"KeepAlive\" || node.tag === \"keep-alive\")) {\n    const rootChildren = filterChild(context.root);\n    if (rootChildren.length === 1 && rootChildren[0] === node) {\n      if (hasSingleChild(node)) {\n        injectFallthroughAttrs(node.children[0]);\n      }\n      return;\n    }\n  }\n  const parent = context.parent;\n  if (!parent || parent.type !== 0) {\n    return;\n  }\n  if (node.type === 10 && hasSingleChild(node)) {\n    let hasEncounteredIf = false;\n    for (const c of filterChild(parent)) {\n      if (c.type === 9 || c.type === 1 && compilerDom.findDir(c, \"if\")) {\n        if (hasEncounteredIf) return;\n        hasEncounteredIf = true;\n      } else if (\n      // node before v-if\n      !hasEncounteredIf ||\n      // non else nodes\n      !(c.type === 1 && compilerDom.findDir(c, /else/, true))) {\n        return;\n      }\n    }\n    injectFallthroughAttrs(node.children[0]);\n  } else if (hasSingleChild(parent)) {\n    injectFallthroughAttrs(node);\n  }\n};\nfunction injectFallthroughAttrs(node) {\n  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, \"for\")) {\n    node.props.push({\n      type: 7,\n      name: \"bind\",\n      arg: void 0,\n      exp: compilerDom.createSimpleExpression(`_attrs`, false),\n      modifiers: [],\n      loc: compilerDom.locStub\n    });\n  }\n}\nconst ssrInjectCssVars = (node, context) => {\n  if (!context.ssrCssVars) {\n    return;\n  }\n  if (node.type === 0) {\n    context.identifiers._cssVars = 1;\n  }\n  const parent = context.parent;\n  if (!parent || parent.type !== 0) {\n    return;\n  }\n  if (node.type === 10) {\n    for (const child of node.children) {\n      injectCssVars(child);\n    }\n  } else {\n    injectCssVars(node);\n  }\n};\nfunction injectCssVars(node) {\n  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, \"for\")) {\n    if (node.tag === \"suspense\" || node.tag === \"Suspense\") {\n      for (const child of node.children) {\n        if (child.type === 1 && child.tagType === 3) {\n          child.children.forEach(injectCssVars);\n        } else {\n          injectCssVars(child);\n        }\n      }\n    } else {\n      node.props.push({\n        type: 7,\n        name: \"bind\",\n        arg: void 0,\n        exp: compilerDom.createSimpleExpression(`_cssVars`, false),\n        modifiers: [],\n        loc: compilerDom.locStub\n      });\n    }\n  }\n}\nfunction compile(source, options = {}) {\n  options = {\n    ...options,\n    ...compilerDom.parserOptions,\n    ssr: true,\n    inSSR: true,\n    scopeId: options.mode === \"function\" ? null : options.scopeId,\n    // always prefix since compiler-ssr doesn't have size concern\n    prefixIdentifiers: true,\n    // disable optimizations that are unnecessary for ssr\n    cacheHandlers: false,\n    hoistStatic: false\n  };\n  const ast = typeof source === \"string\" ? compilerDom.baseParse(source, options) : source;\n  rawOptionsMap.set(ast, options);\n  compilerDom.transform(ast, {\n    ...options,\n    hoistStatic: false,\n    nodeTransforms: [ssrTransformIf, ssrTransformFor, compilerDom.trackVForSlotScopes, compilerDom.transformExpression, ssrTransformSlotOutlet, ssrInjectFallthroughAttrs, ssrInjectCssVars, ssrTransformElement, ssrTransformComponent, compilerDom.trackSlotScopes, compilerDom.transformStyle, ...(options.nodeTransforms || [])\n    // user transforms\n    ],\n    directiveTransforms: {\n      // reusing core v-bind\n      bind: compilerDom.transformBind,\n      on: compilerDom.transformOn,\n      // model and show have dedicated SSR handling\n      model: ssrTransformModel,\n      show: ssrTransformShow,\n      // the following are ignored during SSR\n      // on: noopDirectiveTransform,\n      cloak: compilerDom.noopDirectiveTransform,\n      once: compilerDom.noopDirectiveTransform,\n      memo: compilerDom.noopDirectiveTransform,\n      ...(options.directiveTransforms || {})\n      // user transforms\n    }\n  });\n  ssrCodegenTransform(ast, options);\n  return compilerDom.generate(ast, options);\n}\nexports.compile = compile;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","compilerDom","shared","SSR_INTERPOLATE","Symbol","SSR_RENDER_VNODE","SSR_RENDER_COMPONENT","SSR_RENDER_SLOT","SSR_RENDER_SLOT_INNER","SSR_RENDER_CLASS","SSR_RENDER_STYLE","SSR_RENDER_ATTRS","SSR_RENDER_ATTR","SSR_RENDER_DYNAMIC_ATTR","SSR_RENDER_LIST","SSR_INCLUDE_BOOLEAN_ATTR","SSR_LOOSE_EQUAL","SSR_LOOSE_CONTAIN","SSR_RENDER_DYNAMIC_MODEL","SSR_GET_DYNAMIC_MODEL_PROPS","SSR_RENDER_TELEPORT","SSR_RENDER_SUSPENSE","SSR_GET_DIRECTIVE_PROPS","ssrHelpers","registerRuntimeHelpers","ssrTransformIf","createStructuralDirectiveTransform","processIf","ssrProcessIf","node","context","disableNestedFragments","disableCommentAsIfAlternate","rootBranch","branches","ifStatement","createIfStatement","condition","processIfBranch","pushStatement","currentIf","i","length","branch","branchBlockStatement","alternate","createBlockStatement","createCallExpression","children","needFragmentWrapper","type","processChildrenAsStatement","ssrTransformFor","processFor","ssrProcessFor","renderLoop","createFunctionExpression","createForLoopParams","parseResult","body","pushStringPart","helper","source","ssrTransformSlotOutlet","isSlotOutlet","slotName","slotProps","processSlotOutlet","args","scopeId","slotted","push","method","parent","grandParent","componentType","tagType","resolveComponentType","TRANSITION","TRANSITION_GROUP","filter","c","ssrCodegenNode","ssrProcessSlotOutlet","renderCall","fallbackRenderFn","arguments","withSlotScopeId","slotScopeId","createSSRCompilerError","code","loc","createCompilerError","SSRErrorMessages","ssrProcessTeleport","targetProp","findProp","onError","target","createSimpleExpression","content","exp","disabledProp","disabled","contentRenderFn","wipMap$3","WeakMap","ssrTransformSuspense","wipEntry","slotsExp","wipSlots","set","buildSlots","_props","_vForExp","fn","slots","ssrProcessSuspense","get","slot","rawChildrenMap","ssrTransformElement","ssrPostTransformElement","openTag","tag","needTagForRuntime","indexOf","hasDynamicVBind","hasDynamicKeyVBind","hasCustomDir","props","some","p","isBuiltInDirective","name","needMergeProps","directives","buildProps","mergedProps","buildSSRProps","propsExp","existingText","tempId","temps","createAssignmentExpression","createConditionalExpression","vModel","findVModel","tempExp","createSequenceExpression","MERGE_PROPS","dynamicClassBinding","staticClassBinding","dynamicStyleBinding","prop","isTrueFalseValue","createCompoundExpression","createInterpolation","isTextareaWithValue","directiveTransform","directiveTransforms","ssrTagParts","j","key","isStaticExp","attrName","mergeCall","propsToAttrMap","toLowerCase","isBooleanAttr","isSSRSafeAttrName","escapeHtml","JSON","stringify","removeStaticBinding","createTemplateLiteral","mergePropsArgs","dir","buildDirectiveArgs","elements","arg","isStaticArgOf","call","existing","createArrayExpression","binding","regExp","RegExp","findIndex","e","test","splice","find","ssrProcessElement","isVoidTag","options","NO","elementsToAdd","rawChildren","processChildren","wipMap$2","ssrTransformTransitionGroup","otherProps","ssrProcessTransitionGroup","entry","wipMap$1","ssrTransformTransition","appear","ssrProcessTransition","wipMap","WIP_SLOT","componentTypeMap","ssrTransformComponent","component","isDynamicComponent","isObject","callee","RESOLVE_DYNAMIC_COMPONENT","isSymbol","SUSPENSE","vnodeBranches","clonedNode","clone","ssrPostTransformComponent","vFor","createVNodeSlotBranch","wipEntries","buildSSRSlotFn","param0","stringifyExpression","vnodeBranch","CREATE_VNODE","ssrProcessComponent","TELEPORT","rawOptionsMap","baseNodeTransforms","baseDirectiveTransforms","getBaseTransformPreset","vnodeNodeTransforms","DOMNodeTransforms","vnodeDirectiveTransforms","DOMDirectiveTransforms","parentContext","rawOptions","root","subOptions","nodeTransforms","wrapperProps","modifiers","locStub","extend","wrapperNode","ns","codegenNode","subTransform","createReturnStatement","childRoot","createRoot","childContext","createTransformContext","ssr","scopes","identifiers","imports","traverseNode","forEach","helperKey","parentCount","helpers","add","v","isArray","map","isPlainObject","res","ssrCodegenTransform","ast","createSSRTransformContext","ssrCssVars","cssContext","varsExp","processExpression","Array","from","keys","isFragment","isText","Set","h","currentString","part","currentCall","bufferedElements","lastItem","isString","statement","createChildContext","asFragment","child","exhaustiveCheck2","exhaustiveCheck","ssrTransformModel","model","checkDuplicatedValue","createDOMCompilerError","processOption","plainNode","findValueBinding","option","defaultProps","createObjectProperty","trueValueBinding","trueValue","transformModel","valueBinding","ssrTransformShow","createObjectExpression","filterChild","n","hasSingleChild","ssrInjectFallthroughAttrs","_attrs","rootChildren","injectFallthroughAttrs","hasEncounteredIf","findDir","ssrInjectCssVars","_cssVars","injectCssVars","compile","parserOptions","inSSR","mode","prefixIdentifiers","cacheHandlers","hoistStatic","baseParse","transform","trackVForSlotScopes","transformExpression","trackSlotScopes","transformStyle","bind","transformBind","on","transformOn","show","cloak","noopDirectiveTransform","once","memo","generate"],"sources":["/home/sabi/Desktop/ToDo/frontend/todo/node_modules/@vue/compiler-ssr/dist/compiler-ssr.cjs.js"],"sourcesContent":["/**\n* @vue/compiler-ssr v3.5.6\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerDom = require('@vue/compiler-dom');\nvar shared = require('@vue/shared');\n\nconst SSR_INTERPOLATE = Symbol(`ssrInterpolate`);\nconst SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);\nconst SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);\nconst SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);\nconst SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`);\nconst SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);\nconst SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);\nconst SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);\nconst SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);\nconst SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);\nconst SSR_RENDER_LIST = Symbol(`ssrRenderList`);\nconst SSR_INCLUDE_BOOLEAN_ATTR = Symbol(\n  `ssrIncludeBooleanAttr`\n);\nconst SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);\nconst SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);\nconst SSR_RENDER_DYNAMIC_MODEL = Symbol(\n  `ssrRenderDynamicModel`\n);\nconst SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(\n  `ssrGetDynamicModelProps`\n);\nconst SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);\nconst SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);\nconst SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);\nconst ssrHelpers = {\n  [SSR_INTERPOLATE]: `ssrInterpolate`,\n  [SSR_RENDER_VNODE]: `ssrRenderVNode`,\n  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\n  [SSR_RENDER_SLOT]: `ssrRenderSlot`,\n  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,\n  [SSR_RENDER_CLASS]: `ssrRenderClass`,\n  [SSR_RENDER_STYLE]: `ssrRenderStyle`,\n  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\n  [SSR_RENDER_ATTR]: `ssrRenderAttr`,\n  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\n  [SSR_RENDER_LIST]: `ssrRenderList`,\n  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\n  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\n  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\n  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\n  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\n  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\n  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\n  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`\n};\ncompilerDom.registerRuntimeHelpers(ssrHelpers);\n\nconst ssrTransformIf = compilerDom.createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  compilerDom.processIf\n);\nfunction ssrProcessIf(node, context, disableNestedFragments = false, disableCommentAsIfAlternate = false) {\n  const [rootBranch] = node.branches;\n  const ifStatement = compilerDom.createIfStatement(\n    rootBranch.condition,\n    processIfBranch(rootBranch, context, disableNestedFragments)\n  );\n  context.pushStatement(ifStatement);\n  let currentIf = ifStatement;\n  for (let i = 1; i < node.branches.length; i++) {\n    const branch = node.branches[i];\n    const branchBlockStatement = processIfBranch(\n      branch,\n      context,\n      disableNestedFragments\n    );\n    if (branch.condition) {\n      currentIf = currentIf.alternate = compilerDom.createIfStatement(\n        branch.condition,\n        branchBlockStatement\n      );\n    } else {\n      currentIf.alternate = branchBlockStatement;\n    }\n  }\n  if (!currentIf.alternate && !disableCommentAsIfAlternate) {\n    currentIf.alternate = compilerDom.createBlockStatement([\n      compilerDom.createCallExpression(`_push`, [\"`<!---->`\"])\n    ]);\n  }\n}\nfunction processIfBranch(branch, context, disableNestedFragments = false) {\n  const { children } = branch;\n  const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && // optimize away nested fragments when the only child is a ForNode\n  !(children.length === 1 && children[0].type === 11);\n  return processChildrenAsStatement(branch, context, needFragmentWrapper);\n}\n\nconst ssrTransformFor = compilerDom.createStructuralDirectiveTransform(\"for\", compilerDom.processFor);\nfunction ssrProcessFor(node, context, disableNestedFragments = false) {\n  const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);\n  const renderLoop = compilerDom.createFunctionExpression(\n    compilerDom.createForLoopParams(node.parseResult)\n  );\n  renderLoop.body = processChildrenAsStatement(\n    node,\n    context,\n    needFragmentWrapper\n  );\n  if (!disableNestedFragments) {\n    context.pushStringPart(`<!--[-->`);\n  }\n  context.pushStatement(\n    compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [\n      node.source,\n      renderLoop\n    ])\n  );\n  if (!disableNestedFragments) {\n    context.pushStringPart(`<!--]-->`);\n  }\n}\n\nconst ssrTransformSlotOutlet = (node, context) => {\n  if (compilerDom.isSlotOutlet(node)) {\n    const { slotName, slotProps } = compilerDom.processSlotOutlet(node, context);\n    const args = [\n      `_ctx.$slots`,\n      slotName,\n      slotProps || `{}`,\n      // fallback content placeholder. will be replaced in the process phase\n      `null`,\n      `_push`,\n      `_parent`\n    ];\n    if (context.scopeId && context.slotted !== false) {\n      args.push(`\"${context.scopeId}-s\"`);\n    }\n    let method = SSR_RENDER_SLOT;\n    let parent = context.parent;\n    if (parent) {\n      const children = parent.children;\n      if (parent.type === 10) {\n        parent = context.grandParent;\n      }\n      let componentType;\n      if (parent.type === 1 && parent.tagType === 1 && ((componentType = compilerDom.resolveComponentType(parent, context, true)) === compilerDom.TRANSITION || componentType === compilerDom.TRANSITION_GROUP) && children.filter((c) => c.type === 1).length === 1) {\n        method = SSR_RENDER_SLOT_INNER;\n        if (!(context.scopeId && context.slotted !== false)) {\n          args.push(\"null\");\n        }\n        args.push(\"true\");\n      }\n    }\n    node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(method), args);\n  }\n};\nfunction ssrProcessSlotOutlet(node, context) {\n  const renderCall = node.ssrCodegenNode;\n  if (node.children.length) {\n    const fallbackRenderFn = compilerDom.createFunctionExpression([]);\n    fallbackRenderFn.body = processChildrenAsStatement(node, context);\n    renderCall.arguments[3] = fallbackRenderFn;\n  }\n  if (context.withSlotScopeId) {\n    const slotScopeId = renderCall.arguments[6];\n    renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;\n  }\n  context.pushStatement(node.ssrCodegenNode);\n}\n\nfunction createSSRCompilerError(code, loc) {\n  return compilerDom.createCompilerError(code, loc, SSRErrorMessages);\n}\nconst SSRErrorMessages = {\n  [65]: `Unsafe attribute name for SSR.`,\n  [66]: `Missing the 'to' prop on teleport element.`,\n  [67]: `Invalid AST node during SSR transform.`\n};\n\nfunction ssrProcessTeleport(node, context) {\n  const targetProp = compilerDom.findProp(node, \"to\");\n  if (!targetProp) {\n    context.onError(\n      createSSRCompilerError(66, node.loc)\n    );\n    return;\n  }\n  let target;\n  if (targetProp.type === 6) {\n    target = targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);\n  } else {\n    target = targetProp.exp;\n  }\n  if (!target) {\n    context.onError(\n      createSSRCompilerError(\n        66,\n        targetProp.loc\n      )\n    );\n    return;\n  }\n  const disabledProp = compilerDom.findProp(\n    node,\n    \"disabled\",\n    false,\n    true\n    /* allow empty */\n  );\n  const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;\n  const contentRenderFn = compilerDom.createFunctionExpression(\n    [`_push`],\n    void 0,\n    // Body is added later\n    true,\n    // newline\n    false,\n    // isSlot\n    node.loc\n  );\n  contentRenderFn.body = processChildrenAsStatement(node, context);\n  context.pushStatement(\n    compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [\n      `_push`,\n      contentRenderFn,\n      target,\n      disabled,\n      `_parent`\n    ])\n  );\n}\n\nconst wipMap$3 = /* @__PURE__ */ new WeakMap();\nfunction ssrTransformSuspense(node, context) {\n  return () => {\n    if (node.children.length) {\n      const wipEntry = {\n        slotsExp: null,\n        // to be immediately set\n        wipSlots: []\n      };\n      wipMap$3.set(node, wipEntry);\n      wipEntry.slotsExp = compilerDom.buildSlots(\n        node,\n        context,\n        (_props, _vForExp, children, loc) => {\n          const fn = compilerDom.createFunctionExpression(\n            [],\n            void 0,\n            // no return, assign body later\n            true,\n            // newline\n            false,\n            // suspense slots are not treated as normal slots\n            loc\n          );\n          wipEntry.wipSlots.push({\n            fn,\n            children\n          });\n          return fn;\n        }\n      ).slots;\n    }\n  };\n}\nfunction ssrProcessSuspense(node, context) {\n  const wipEntry = wipMap$3.get(node);\n  if (!wipEntry) {\n    return;\n  }\n  const { slotsExp, wipSlots } = wipEntry;\n  for (let i = 0; i < wipSlots.length; i++) {\n    const slot = wipSlots[i];\n    slot.fn.body = processChildrenAsStatement(slot, context);\n  }\n  context.pushStatement(\n    compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [\n      `_push`,\n      slotsExp\n    ])\n  );\n}\n\nconst rawChildrenMap = /* @__PURE__ */ new WeakMap();\nconst ssrTransformElement = (node, context) => {\n  if (node.type !== 1 || node.tagType !== 0) {\n    return;\n  }\n  return function ssrPostTransformElement() {\n    const openTag = [`<${node.tag}`];\n    const needTagForRuntime = node.tag === \"textarea\" || node.tag.indexOf(\"-\") > 0;\n    const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);\n    const hasCustomDir = node.props.some(\n      (p) => p.type === 7 && !shared.isBuiltInDirective(p.name)\n    );\n    const needMergeProps = hasDynamicVBind || hasCustomDir;\n    if (needMergeProps) {\n      const { props, directives } = compilerDom.buildProps(\n        node,\n        context,\n        node.props,\n        false,\n        false,\n        true\n      );\n      if (props || directives.length) {\n        const mergedProps = buildSSRProps(props, directives, context);\n        const propsExp = compilerDom.createCallExpression(\n          context.helper(SSR_RENDER_ATTRS),\n          [mergedProps]\n        );\n        if (node.tag === \"textarea\") {\n          const existingText = node.children[0];\n          if (!existingText || existingText.type !== 5) {\n            const tempId = `_temp${context.temps++}`;\n            propsExp.arguments = [\n              compilerDom.createAssignmentExpression(\n                compilerDom.createSimpleExpression(tempId, false),\n                mergedProps\n              )\n            ];\n            rawChildrenMap.set(\n              node,\n              compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [\n                compilerDom.createConditionalExpression(\n                  compilerDom.createSimpleExpression(`\"value\" in ${tempId}`, false),\n                  compilerDom.createSimpleExpression(`${tempId}.value`, false),\n                  compilerDom.createSimpleExpression(\n                    existingText ? existingText.content : ``,\n                    true\n                  ),\n                  false\n                )\n              ])\n            );\n          }\n        } else if (node.tag === \"input\") {\n          const vModel = findVModel(node);\n          if (vModel) {\n            const tempId = `_temp${context.temps++}`;\n            const tempExp = compilerDom.createSimpleExpression(tempId, false);\n            propsExp.arguments = [\n              compilerDom.createSequenceExpression([\n                compilerDom.createAssignmentExpression(tempExp, mergedProps),\n                compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [\n                  tempExp,\n                  compilerDom.createCallExpression(\n                    context.helper(SSR_GET_DYNAMIC_MODEL_PROPS),\n                    [\n                      tempExp,\n                      // existing props\n                      vModel.exp\n                      // model\n                    ]\n                  )\n                ])\n              ])\n            ];\n          }\n        } else if (directives.length && !node.children.length) {\n          const tempId = `_temp${context.temps++}`;\n          propsExp.arguments = [\n            compilerDom.createAssignmentExpression(\n              compilerDom.createSimpleExpression(tempId, false),\n              mergedProps\n            )\n          ];\n          rawChildrenMap.set(\n            node,\n            compilerDom.createConditionalExpression(\n              compilerDom.createSimpleExpression(`\"textContent\" in ${tempId}`, false),\n              compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [\n                compilerDom.createSimpleExpression(`${tempId}.textContent`, false)\n              ]),\n              compilerDom.createSimpleExpression(`${tempId}.innerHTML ?? ''`, false),\n              false\n            )\n          );\n        }\n        if (needTagForRuntime) {\n          propsExp.arguments.push(`\"${node.tag}\"`);\n        }\n        openTag.push(propsExp);\n      }\n    }\n    let dynamicClassBinding = void 0;\n    let staticClassBinding = void 0;\n    let dynamicStyleBinding = void 0;\n    for (let i = 0; i < node.props.length; i++) {\n      const prop = node.props[i];\n      if (node.tag === \"input\" && isTrueFalseValue(prop)) {\n        continue;\n      }\n      if (prop.type === 7) {\n        if (prop.name === \"html\" && prop.exp) {\n          rawChildrenMap.set(\n            node,\n            compilerDom.createCompoundExpression([`(`, prop.exp, `) ?? ''`])\n          );\n        } else if (prop.name === \"text\" && prop.exp) {\n          node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\n        } else if (prop.name === \"slot\") {\n          context.onError(\n            compilerDom.createCompilerError(40, prop.loc)\n          );\n        } else if (isTextareaWithValue(node, prop) && prop.exp) {\n          if (!needMergeProps) {\n            node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\n          }\n        } else if (!needMergeProps && prop.name !== \"on\") {\n          const directiveTransform = context.directiveTransforms[prop.name];\n          if (directiveTransform) {\n            const { props, ssrTagParts } = directiveTransform(\n              prop,\n              node,\n              context\n            );\n            if (ssrTagParts) {\n              openTag.push(...ssrTagParts);\n            }\n            for (let j = 0; j < props.length; j++) {\n              const { key, value } = props[j];\n              if (compilerDom.isStaticExp(key)) {\n                let attrName = key.content;\n                if (attrName === \"key\" || attrName === \"ref\") {\n                  continue;\n                }\n                if (attrName === \"class\") {\n                  openTag.push(\n                    ` class=\"`,\n                    dynamicClassBinding = compilerDom.createCallExpression(\n                      context.helper(SSR_RENDER_CLASS),\n                      [value]\n                    ),\n                    `\"`\n                  );\n                } else if (attrName === \"style\") {\n                  if (dynamicStyleBinding) {\n                    mergeCall(dynamicStyleBinding, value);\n                  } else {\n                    openTag.push(\n                      ` style=\"`,\n                      dynamicStyleBinding = compilerDom.createCallExpression(\n                        context.helper(SSR_RENDER_STYLE),\n                        [value]\n                      ),\n                      `\"`\n                    );\n                  }\n                } else {\n                  attrName = node.tag.indexOf(\"-\") > 0 ? attrName : shared.propsToAttrMap[attrName] || attrName.toLowerCase();\n                  if (shared.isBooleanAttr(attrName)) {\n                    openTag.push(\n                      compilerDom.createConditionalExpression(\n                        compilerDom.createCallExpression(\n                          context.helper(SSR_INCLUDE_BOOLEAN_ATTR),\n                          [value]\n                        ),\n                        compilerDom.createSimpleExpression(\" \" + attrName, true),\n                        compilerDom.createSimpleExpression(\"\", true),\n                        false\n                      )\n                    );\n                  } else if (shared.isSSRSafeAttrName(attrName)) {\n                    openTag.push(\n                      compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [\n                        key,\n                        value\n                      ])\n                    );\n                  } else {\n                    context.onError(\n                      createSSRCompilerError(\n                        65,\n                        key.loc\n                      )\n                    );\n                  }\n                }\n              } else {\n                const args = [key, value];\n                if (needTagForRuntime) {\n                  args.push(`\"${node.tag}\"`);\n                }\n                openTag.push(\n                  compilerDom.createCallExpression(\n                    context.helper(SSR_RENDER_DYNAMIC_ATTR),\n                    args\n                  )\n                );\n              }\n            }\n          }\n        }\n      } else {\n        const name = prop.name;\n        if (node.tag === \"textarea\" && name === \"value\" && prop.value) {\n          rawChildrenMap.set(node, shared.escapeHtml(prop.value.content));\n        } else if (!needMergeProps) {\n          if (name === \"key\" || name === \"ref\") {\n            continue;\n          }\n          if (name === \"class\" && prop.value) {\n            staticClassBinding = JSON.stringify(prop.value.content);\n          }\n          openTag.push(\n            ` ${prop.name}` + (prop.value ? `=\"${shared.escapeHtml(prop.value.content)}\"` : ``)\n          );\n        }\n      }\n    }\n    if (dynamicClassBinding && staticClassBinding) {\n      mergeCall(dynamicClassBinding, staticClassBinding);\n      removeStaticBinding(openTag, \"class\");\n    }\n    if (context.scopeId) {\n      openTag.push(` ${context.scopeId}`);\n    }\n    node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);\n  };\n};\nfunction buildSSRProps(props, directives, context) {\n  let mergePropsArgs = [];\n  if (props) {\n    if (props.type === 14) {\n      mergePropsArgs = props.arguments;\n    } else {\n      mergePropsArgs.push(props);\n    }\n  }\n  if (directives.length) {\n    for (const dir of directives) {\n      mergePropsArgs.push(\n        compilerDom.createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [\n          `_ctx`,\n          ...compilerDom.buildDirectiveArgs(dir, context).elements\n        ])\n      );\n    }\n  }\n  return mergePropsArgs.length > 1 ? compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), mergePropsArgs) : mergePropsArgs[0];\n}\nfunction isTrueFalseValue(prop) {\n  if (prop.type === 7) {\n    return prop.name === \"bind\" && prop.arg && compilerDom.isStaticExp(prop.arg) && (prop.arg.content === \"true-value\" || prop.arg.content === \"false-value\");\n  } else {\n    return prop.name === \"true-value\" || prop.name === \"false-value\";\n  }\n}\nfunction isTextareaWithValue(node, prop) {\n  return !!(node.tag === \"textarea\" && prop.name === \"bind\" && compilerDom.isStaticArgOf(prop.arg, \"value\"));\n}\nfunction mergeCall(call, arg) {\n  const existing = call.arguments[0];\n  if (existing.type === 17) {\n    existing.elements.push(arg);\n  } else {\n    call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);\n  }\n}\nfunction removeStaticBinding(tag, binding) {\n  const regExp = new RegExp(`^ ${binding}=\".+\"$`);\n  const i = tag.findIndex((e) => typeof e === \"string\" && regExp.test(e));\n  if (i > -1) {\n    tag.splice(i, 1);\n  }\n}\nfunction findVModel(node) {\n  return node.props.find(\n    (p) => p.type === 7 && p.name === \"model\" && p.exp\n  );\n}\nfunction ssrProcessElement(node, context) {\n  const isVoidTag = context.options.isVoidTag || shared.NO;\n  const elementsToAdd = node.ssrCodegenNode.elements;\n  for (let j = 0; j < elementsToAdd.length; j++) {\n    context.pushStringPart(elementsToAdd[j]);\n  }\n  if (context.withSlotScopeId) {\n    context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));\n  }\n  context.pushStringPart(`>`);\n  const rawChildren = rawChildrenMap.get(node);\n  if (rawChildren) {\n    context.pushStringPart(rawChildren);\n  } else if (node.children.length) {\n    processChildren(node, context);\n  }\n  if (!isVoidTag(node.tag)) {\n    context.pushStringPart(`</${node.tag}>`);\n  }\n}\n\nconst wipMap$2 = /* @__PURE__ */ new WeakMap();\nfunction ssrTransformTransitionGroup(node, context) {\n  return () => {\n    const tag = compilerDom.findProp(node, \"tag\");\n    if (tag) {\n      const otherProps = node.props.filter((p) => p !== tag);\n      const { props, directives } = compilerDom.buildProps(\n        node,\n        context,\n        otherProps,\n        true,\n        false,\n        true\n      );\n      let propsExp = null;\n      if (props || directives.length) {\n        propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [\n          buildSSRProps(props, directives, context)\n        ]);\n      }\n      wipMap$2.set(node, {\n        tag,\n        propsExp,\n        scopeId: context.scopeId || null\n      });\n    }\n  };\n}\nfunction ssrProcessTransitionGroup(node, context) {\n  const entry = wipMap$2.get(node);\n  if (entry) {\n    const { tag, propsExp, scopeId } = entry;\n    if (tag.type === 7) {\n      context.pushStringPart(`<`);\n      context.pushStringPart(tag.exp);\n      if (propsExp) {\n        context.pushStringPart(propsExp);\n      }\n      if (scopeId) {\n        context.pushStringPart(` ${scopeId}`);\n      }\n      context.pushStringPart(`>`);\n      processChildren(\n        node,\n        context,\n        false,\n        /**\n         * TransitionGroup has the special runtime behavior of flattening and\n         * concatenating all children into a single fragment (in order for them to\n         * be patched using the same key map) so we need to account for that here\n         * by disabling nested fragment wrappers from being generated.\n         */\n        true,\n        /**\n         * TransitionGroup filters out comment children at runtime and thus\n         * doesn't expect comments to be present during hydration. We need to\n         * account for that by disabling the empty comment that is otherwise\n         * rendered for a falsy v-if that has no v-else specified. (#6715)\n         */\n        true\n      );\n      context.pushStringPart(`</`);\n      context.pushStringPart(tag.exp);\n      context.pushStringPart(`>`);\n    } else {\n      context.pushStringPart(`<${tag.value.content}`);\n      if (propsExp) {\n        context.pushStringPart(propsExp);\n      }\n      if (scopeId) {\n        context.pushStringPart(` ${scopeId}`);\n      }\n      context.pushStringPart(`>`);\n      processChildren(node, context, false, true, true);\n      context.pushStringPart(`</${tag.value.content}>`);\n    }\n  } else {\n    processChildren(node, context, true, true, true);\n  }\n}\n\nconst wipMap$1 = /* @__PURE__ */ new WeakMap();\nfunction ssrTransformTransition(node, context) {\n  return () => {\n    const appear = compilerDom.findProp(node, \"appear\", false, true);\n    wipMap$1.set(node, !!appear);\n  };\n}\nfunction ssrProcessTransition(node, context) {\n  node.children = node.children.filter((c) => c.type !== 3);\n  const appear = wipMap$1.get(node);\n  if (appear) {\n    context.pushStringPart(`<template>`);\n    processChildren(node, context, false, true);\n    context.pushStringPart(`</template>`);\n  } else {\n    processChildren(node, context, false, true);\n  }\n}\n\nconst wipMap = /* @__PURE__ */ new WeakMap();\nconst WIP_SLOT = Symbol();\nconst componentTypeMap = /* @__PURE__ */ new WeakMap();\nconst ssrTransformComponent = (node, context) => {\n  if (node.type !== 1 || node.tagType !== 1) {\n    return;\n  }\n  const component = compilerDom.resolveComponentType(\n    node,\n    context,\n    true\n    /* ssr */\n  );\n  const isDynamicComponent = shared.isObject(component) && component.callee === compilerDom.RESOLVE_DYNAMIC_COMPONENT;\n  componentTypeMap.set(node, component);\n  if (shared.isSymbol(component)) {\n    if (component === compilerDom.SUSPENSE) {\n      return ssrTransformSuspense(node, context);\n    } else if (component === compilerDom.TRANSITION_GROUP) {\n      return ssrTransformTransitionGroup(node, context);\n    } else if (component === compilerDom.TRANSITION) {\n      return ssrTransformTransition(node);\n    }\n    return;\n  }\n  const vnodeBranches = [];\n  const clonedNode = clone(node);\n  return function ssrPostTransformComponent() {\n    if (clonedNode.children.length) {\n      compilerDom.buildSlots(clonedNode, context, (props, vFor, children) => {\n        vnodeBranches.push(\n          createVNodeSlotBranch(props, vFor, children, context)\n        );\n        return compilerDom.createFunctionExpression(void 0);\n      });\n    }\n    let propsExp = `null`;\n    if (node.props.length) {\n      const { props, directives } = compilerDom.buildProps(\n        node,\n        context,\n        void 0,\n        true,\n        isDynamicComponent\n      );\n      if (props || directives.length) {\n        propsExp = buildSSRProps(props, directives, context);\n      }\n    }\n    const wipEntries = [];\n    wipMap.set(node, wipEntries);\n    const buildSSRSlotFn = (props, _vForExp, children, loc) => {\n      const param0 = props && compilerDom.stringifyExpression(props) || `_`;\n      const fn = compilerDom.createFunctionExpression(\n        [param0, `_push`, `_parent`, `_scopeId`],\n        void 0,\n        // no return, assign body later\n        true,\n        // newline\n        true,\n        // isSlot\n        loc\n      );\n      wipEntries.push({\n        type: WIP_SLOT,\n        fn,\n        children,\n        // also collect the corresponding vnode branch built earlier\n        vnodeBranch: vnodeBranches[wipEntries.length]\n      });\n      return fn;\n    };\n    const slots = node.children.length ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots : `null`;\n    if (typeof component !== \"string\") {\n      node.ssrCodegenNode = compilerDom.createCallExpression(\n        context.helper(SSR_RENDER_VNODE),\n        [\n          `_push`,\n          compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [\n            component,\n            propsExp,\n            slots\n          ]),\n          `_parent`\n        ]\n      );\n    } else {\n      node.ssrCodegenNode = compilerDom.createCallExpression(\n        context.helper(SSR_RENDER_COMPONENT),\n        [component, propsExp, slots, `_parent`]\n      );\n    }\n  };\n};\nfunction ssrProcessComponent(node, context, parent) {\n  const component = componentTypeMap.get(node);\n  if (!node.ssrCodegenNode) {\n    if (component === compilerDom.TELEPORT) {\n      return ssrProcessTeleport(node, context);\n    } else if (component === compilerDom.SUSPENSE) {\n      return ssrProcessSuspense(node, context);\n    } else if (component === compilerDom.TRANSITION_GROUP) {\n      return ssrProcessTransitionGroup(node, context);\n    } else {\n      if (parent.type === WIP_SLOT) {\n        context.pushStringPart(``);\n      }\n      if (component === compilerDom.TRANSITION) {\n        return ssrProcessTransition(node, context);\n      }\n      processChildren(node, context);\n    }\n  } else {\n    const wipEntries = wipMap.get(node) || [];\n    for (let i = 0; i < wipEntries.length; i++) {\n      const { fn, vnodeBranch } = wipEntries[i];\n      fn.body = compilerDom.createIfStatement(\n        compilerDom.createSimpleExpression(`_push`, false),\n        processChildrenAsStatement(\n          wipEntries[i],\n          context,\n          false,\n          true\n        ),\n        vnodeBranch\n      );\n    }\n    if (context.withSlotScopeId) {\n      node.ssrCodegenNode.arguments.push(`_scopeId`);\n    }\n    if (typeof component === \"string\") {\n      context.pushStatement(\n        compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode])\n      );\n    } else {\n      context.pushStatement(node.ssrCodegenNode);\n    }\n  }\n}\nconst rawOptionsMap = /* @__PURE__ */ new WeakMap();\nconst [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];\nconst vnodeDirectiveTransforms = {\n  ...baseDirectiveTransforms,\n  ...compilerDom.DOMDirectiveTransforms\n};\nfunction createVNodeSlotBranch(slotProps, vFor, children, parentContext) {\n  const rawOptions = rawOptionsMap.get(parentContext.root);\n  const subOptions = {\n    ...rawOptions,\n    // overwrite with vnode-based transforms\n    nodeTransforms: [\n      ...vnodeNodeTransforms,\n      ...rawOptions.nodeTransforms || []\n    ],\n    directiveTransforms: {\n      ...vnodeDirectiveTransforms,\n      ...rawOptions.directiveTransforms || {}\n    }\n  };\n  const wrapperProps = [];\n  if (slotProps) {\n    wrapperProps.push({\n      type: 7,\n      name: \"slot\",\n      exp: slotProps,\n      arg: void 0,\n      modifiers: [],\n      loc: compilerDom.locStub\n    });\n  }\n  if (vFor) {\n    wrapperProps.push(shared.extend({}, vFor));\n  }\n  const wrapperNode = {\n    type: 1,\n    ns: 0,\n    tag: \"template\",\n    tagType: 3,\n    props: wrapperProps,\n    children,\n    loc: compilerDom.locStub,\n    codegenNode: void 0\n  };\n  subTransform(wrapperNode, subOptions, parentContext);\n  return compilerDom.createReturnStatement(children);\n}\nfunction subTransform(node, options, parentContext) {\n  const childRoot = compilerDom.createRoot([node]);\n  const childContext = compilerDom.createTransformContext(childRoot, options);\n  childContext.ssr = false;\n  childContext.scopes = { ...parentContext.scopes };\n  childContext.identifiers = { ...parentContext.identifiers };\n  childContext.imports = parentContext.imports;\n  compilerDom.traverseNode(childRoot, childContext);\n  [\"helpers\", \"components\", \"directives\"].forEach((key) => {\n    childContext[key].forEach((value, helperKey) => {\n      if (key === \"helpers\") {\n        const parentCount = parentContext.helpers.get(helperKey);\n        if (parentCount === void 0) {\n          parentContext.helpers.set(helperKey, value);\n        } else {\n          parentContext.helpers.set(helperKey, value + parentCount);\n        }\n      } else {\n        parentContext[key].add(value);\n      }\n    });\n  });\n}\nfunction clone(v) {\n  if (shared.isArray(v)) {\n    return v.map(clone);\n  } else if (shared.isPlainObject(v)) {\n    const res = {};\n    for (const key in v) {\n      res[key] = clone(v[key]);\n    }\n    return res;\n  } else {\n    return v;\n  }\n}\n\nfunction ssrCodegenTransform(ast, options) {\n  const context = createSSRTransformContext(ast, options);\n  if (options.ssrCssVars) {\n    const cssContext = compilerDom.createTransformContext(compilerDom.createRoot([]), options);\n    const varsExp = compilerDom.processExpression(\n      compilerDom.createSimpleExpression(options.ssrCssVars, false),\n      cssContext\n    );\n    context.body.push(\n      compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`])\n    );\n    Array.from(cssContext.helpers.keys()).forEach((helper) => {\n      ast.helpers.add(helper);\n    });\n  }\n  const isFragment = ast.children.length > 1 && ast.children.some((c) => !compilerDom.isText(c));\n  processChildren(ast, context, isFragment);\n  ast.codegenNode = compilerDom.createBlockStatement(context.body);\n  ast.ssrHelpers = Array.from(\n    /* @__PURE__ */ new Set([\n      ...Array.from(ast.helpers).filter((h) => h in ssrHelpers),\n      ...context.helpers\n    ])\n  );\n  ast.helpers = new Set(Array.from(ast.helpers).filter((h) => !(h in ssrHelpers)));\n}\nfunction createSSRTransformContext(root, options, helpers = /* @__PURE__ */ new Set(), withSlotScopeId = false) {\n  const body = [];\n  let currentString = null;\n  return {\n    root,\n    options,\n    body,\n    helpers,\n    withSlotScopeId,\n    onError: options.onError || ((e) => {\n      throw e;\n    }),\n    helper(name) {\n      helpers.add(name);\n      return name;\n    },\n    pushStringPart(part) {\n      if (!currentString) {\n        const currentCall = compilerDom.createCallExpression(`_push`);\n        body.push(currentCall);\n        currentString = compilerDom.createTemplateLiteral([]);\n        currentCall.arguments.push(currentString);\n      }\n      const bufferedElements = currentString.elements;\n      const lastItem = bufferedElements[bufferedElements.length - 1];\n      if (shared.isString(part) && shared.isString(lastItem)) {\n        bufferedElements[bufferedElements.length - 1] += part;\n      } else {\n        bufferedElements.push(part);\n      }\n    },\n    pushStatement(statement) {\n      currentString = null;\n      body.push(statement);\n    }\n  };\n}\nfunction createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {\n  return createSSRTransformContext(\n    parent.root,\n    parent.options,\n    parent.helpers,\n    withSlotScopeId\n  );\n}\nfunction processChildren(parent, context, asFragment = false, disableNestedFragments = false, disableCommentAsIfAlternate = false) {\n  if (asFragment) {\n    context.pushStringPart(`<!--[-->`);\n  }\n  const { children } = parent;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    switch (child.type) {\n      case 1:\n        switch (child.tagType) {\n          case 0:\n            ssrProcessElement(child, context);\n            break;\n          case 1:\n            ssrProcessComponent(child, context, parent);\n            break;\n          case 2:\n            ssrProcessSlotOutlet(child, context);\n            break;\n          case 3:\n            break;\n          default:\n            context.onError(\n              createSSRCompilerError(\n                67,\n                child.loc\n              )\n            );\n            const exhaustiveCheck2 = child;\n            return exhaustiveCheck2;\n        }\n        break;\n      case 2:\n        context.pushStringPart(shared.escapeHtml(child.content));\n        break;\n      case 3:\n        context.pushStringPart(`<!--${child.content}-->`);\n        break;\n      case 5:\n        context.pushStringPart(\n          compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [\n            child.content\n          ])\n        );\n        break;\n      case 9:\n        ssrProcessIf(\n          child,\n          context,\n          disableNestedFragments,\n          disableCommentAsIfAlternate\n        );\n        break;\n      case 11:\n        ssrProcessFor(child, context, disableNestedFragments);\n        break;\n      case 10:\n        break;\n      case 12:\n      case 8:\n        break;\n      default:\n        context.onError(\n          createSSRCompilerError(\n            67,\n            child.loc\n          )\n        );\n        const exhaustiveCheck = child;\n        return exhaustiveCheck;\n    }\n  }\n  if (asFragment) {\n    context.pushStringPart(`<!--]-->`);\n  }\n}\nfunction processChildrenAsStatement(parent, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {\n  const childContext = createChildContext(parentContext, withSlotScopeId);\n  processChildren(parent, childContext, asFragment);\n  return compilerDom.createBlockStatement(childContext.body);\n}\n\nconst ssrTransformModel = (dir, node, context) => {\n  const model = dir.exp;\n  function checkDuplicatedValue() {\n    const value = compilerDom.findProp(node, \"value\");\n    if (value) {\n      context.onError(\n        compilerDom.createDOMCompilerError(\n          60,\n          value.loc\n        )\n      );\n    }\n  }\n  function processOption(plainNode) {\n    if (plainNode.tag === \"option\") {\n      if (plainNode.props.findIndex((p) => p.name === \"selected\") === -1) {\n        const value = findValueBinding(plainNode);\n        plainNode.ssrCodegenNode.elements.push(\n          compilerDom.createConditionalExpression(\n            compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [\n              compilerDom.createConditionalExpression(\n                compilerDom.createCallExpression(`Array.isArray`, [model]),\n                compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\n                  model,\n                  value\n                ]),\n                compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                  model,\n                  value\n                ])\n              )\n            ]),\n            compilerDom.createSimpleExpression(\" selected\", true),\n            compilerDom.createSimpleExpression(\"\", true),\n            false\n          )\n        );\n      }\n    } else if (plainNode.tag === \"optgroup\") {\n      plainNode.children.forEach(\n        (option) => processOption(option)\n      );\n    }\n  }\n  if (node.tagType === 0) {\n    const res = { props: [] };\n    const defaultProps = [\n      // default value binding for text type inputs\n      compilerDom.createObjectProperty(`value`, model)\n    ];\n    if (node.tag === \"input\") {\n      const type = compilerDom.findProp(node, \"type\");\n      if (type) {\n        const value = findValueBinding(node);\n        if (type.type === 7) {\n          res.ssrTagParts = [\n            compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [\n              type.exp,\n              model,\n              value\n            ])\n          ];\n        } else if (type.value) {\n          switch (type.value.content) {\n            case \"radio\":\n              res.props = [\n                compilerDom.createObjectProperty(\n                  `checked`,\n                  compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                    model,\n                    value\n                  ])\n                )\n              ];\n              break;\n            case \"checkbox\":\n              const trueValueBinding = compilerDom.findProp(node, \"true-value\");\n              if (trueValueBinding) {\n                const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;\n                res.props = [\n                  compilerDom.createObjectProperty(\n                    `checked`,\n                    compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                      model,\n                      trueValue\n                    ])\n                  )\n                ];\n              } else {\n                res.props = [\n                  compilerDom.createObjectProperty(\n                    `checked`,\n                    compilerDom.createConditionalExpression(\n                      compilerDom.createCallExpression(`Array.isArray`, [model]),\n                      compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\n                        model,\n                        value\n                      ]),\n                      model\n                    )\n                  )\n                ];\n              }\n              break;\n            case \"file\":\n              context.onError(\n                compilerDom.createDOMCompilerError(\n                  59,\n                  dir.loc\n                )\n              );\n              break;\n            default:\n              checkDuplicatedValue();\n              res.props = defaultProps;\n              break;\n          }\n        }\n      } else if (compilerDom.hasDynamicKeyVBind(node)) ; else {\n        checkDuplicatedValue();\n        res.props = defaultProps;\n      }\n    } else if (node.tag === \"textarea\") {\n      checkDuplicatedValue();\n      node.children = [compilerDom.createInterpolation(model, model.loc)];\n    } else if (node.tag === \"select\") {\n      node.children.forEach((child) => {\n        if (child.type === 1) {\n          processOption(child);\n        }\n      });\n    } else {\n      context.onError(\n        compilerDom.createDOMCompilerError(\n          57,\n          dir.loc\n        )\n      );\n    }\n    return res;\n  } else {\n    return compilerDom.transformModel(dir, node, context);\n  }\n};\nfunction findValueBinding(node) {\n  const valueBinding = compilerDom.findProp(node, \"value\");\n  return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : compilerDom.createSimpleExpression(valueBinding.value.content, true) : compilerDom.createSimpleExpression(`null`, false);\n}\n\nconst ssrTransformShow = (dir, node, context) => {\n  if (!dir.exp) {\n    context.onError(\n      compilerDom.createDOMCompilerError(61)\n    );\n  }\n  return {\n    props: [\n      compilerDom.createObjectProperty(\n        `style`,\n        compilerDom.createConditionalExpression(\n          dir.exp,\n          compilerDom.createSimpleExpression(`null`, false),\n          compilerDom.createObjectExpression([\n            compilerDom.createObjectProperty(\n              `display`,\n              compilerDom.createSimpleExpression(`none`, true)\n            )\n          ]),\n          false\n        )\n      )\n    ]\n  };\n};\n\nconst filterChild = (node) => node.children.filter((n) => n.type !== 3);\nconst hasSingleChild = (node) => filterChild(node).length === 1;\nconst ssrInjectFallthroughAttrs = (node, context) => {\n  if (node.type === 0) {\n    context.identifiers._attrs = 1;\n  }\n  if (node.type === 1 && node.tagType === 1 && (node.tag === \"transition\" || node.tag === \"Transition\" || node.tag === \"KeepAlive\" || node.tag === \"keep-alive\")) {\n    const rootChildren = filterChild(context.root);\n    if (rootChildren.length === 1 && rootChildren[0] === node) {\n      if (hasSingleChild(node)) {\n        injectFallthroughAttrs(node.children[0]);\n      }\n      return;\n    }\n  }\n  const parent = context.parent;\n  if (!parent || parent.type !== 0) {\n    return;\n  }\n  if (node.type === 10 && hasSingleChild(node)) {\n    let hasEncounteredIf = false;\n    for (const c of filterChild(parent)) {\n      if (c.type === 9 || c.type === 1 && compilerDom.findDir(c, \"if\")) {\n        if (hasEncounteredIf) return;\n        hasEncounteredIf = true;\n      } else if (\n        // node before v-if\n        !hasEncounteredIf || // non else nodes\n        !(c.type === 1 && compilerDom.findDir(c, /else/, true))\n      ) {\n        return;\n      }\n    }\n    injectFallthroughAttrs(node.children[0]);\n  } else if (hasSingleChild(parent)) {\n    injectFallthroughAttrs(node);\n  }\n};\nfunction injectFallthroughAttrs(node) {\n  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, \"for\")) {\n    node.props.push({\n      type: 7,\n      name: \"bind\",\n      arg: void 0,\n      exp: compilerDom.createSimpleExpression(`_attrs`, false),\n      modifiers: [],\n      loc: compilerDom.locStub\n    });\n  }\n}\n\nconst ssrInjectCssVars = (node, context) => {\n  if (!context.ssrCssVars) {\n    return;\n  }\n  if (node.type === 0) {\n    context.identifiers._cssVars = 1;\n  }\n  const parent = context.parent;\n  if (!parent || parent.type !== 0) {\n    return;\n  }\n  if (node.type === 10) {\n    for (const child of node.children) {\n      injectCssVars(child);\n    }\n  } else {\n    injectCssVars(node);\n  }\n};\nfunction injectCssVars(node) {\n  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, \"for\")) {\n    if (node.tag === \"suspense\" || node.tag === \"Suspense\") {\n      for (const child of node.children) {\n        if (child.type === 1 && child.tagType === 3) {\n          child.children.forEach(injectCssVars);\n        } else {\n          injectCssVars(child);\n        }\n      }\n    } else {\n      node.props.push({\n        type: 7,\n        name: \"bind\",\n        arg: void 0,\n        exp: compilerDom.createSimpleExpression(`_cssVars`, false),\n        modifiers: [],\n        loc: compilerDom.locStub\n      });\n    }\n  }\n}\n\nfunction compile(source, options = {}) {\n  options = {\n    ...options,\n    ...compilerDom.parserOptions,\n    ssr: true,\n    inSSR: true,\n    scopeId: options.mode === \"function\" ? null : options.scopeId,\n    // always prefix since compiler-ssr doesn't have size concern\n    prefixIdentifiers: true,\n    // disable optimizations that are unnecessary for ssr\n    cacheHandlers: false,\n    hoistStatic: false\n  };\n  const ast = typeof source === \"string\" ? compilerDom.baseParse(source, options) : source;\n  rawOptionsMap.set(ast, options);\n  compilerDom.transform(ast, {\n    ...options,\n    hoistStatic: false,\n    nodeTransforms: [\n      ssrTransformIf,\n      ssrTransformFor,\n      compilerDom.trackVForSlotScopes,\n      compilerDom.transformExpression,\n      ssrTransformSlotOutlet,\n      ssrInjectFallthroughAttrs,\n      ssrInjectCssVars,\n      ssrTransformElement,\n      ssrTransformComponent,\n      compilerDom.trackSlotScopes,\n      compilerDom.transformStyle,\n      ...options.nodeTransforms || []\n      // user transforms\n    ],\n    directiveTransforms: {\n      // reusing core v-bind\n      bind: compilerDom.transformBind,\n      on: compilerDom.transformOn,\n      // model and show have dedicated SSR handling\n      model: ssrTransformModel,\n      show: ssrTransformShow,\n      // the following are ignored during SSR\n      // on: noopDirectiveTransform,\n      cloak: compilerDom.noopDirectiveTransform,\n      once: compilerDom.noopDirectiveTransform,\n      memo: compilerDom.noopDirectiveTransform,\n      ...options.directiveTransforms || {}\n      // user transforms\n    }\n  });\n  ssrCodegenTransform(ast, options);\n  return compilerDom.generate(ast, options);\n}\n\nexports.compile = compile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}